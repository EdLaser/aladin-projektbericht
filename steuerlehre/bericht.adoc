:source-highlighter: rouge
:imagesdir: img
== Steuerrecht

=== Aufgabenbeschreibung
==== Gegebenheiten / Design der Aufgabe
Meine Augfabe im Projektseminar war es, Aufgaben zum Steuerrecht umzusetzen. Dabei ging es darum, Aufgaben zu generieren bei denen die Studierenden das zu versteuernde Einkommen berechnet. Die Aufgaben sollen mit zufälligen Werten und Kombinationen aus einem Pool und Sachverhaltstypen generiert werden. Um die Lösung des Studenten zu prüfen, muss neben der Aufgabe auch noch die dazugehörige Lösung erstellt werden.
Basis dieser Aufgaben bildet ein Text, mit unterschiedlichen steuerlichen Sachverhalten, welche die Studierenden herauslesen müssen. Die Sachverhalte sind dabei miteiander verwoben, können aber müssen nicht aufeinander aufbauen. Dies soll dazu führen, dass die Studierenden zum aktiven Kombinieren angeregt werden. Die Anzahl an unterschieldichen Sachverhaltstypen, soll stetig erweiterbar bleiben, im Moment werden Gehalt, Kapitalvermögen, Vermietung und für alle Typen Werbungskosten unterstützt.
Um eine natürliche Satzstruktur zu wahren, muss der Text dabei unterschiedliche Satzkonstruktionen enhalten. Dazu sollen mehrere 'Versionen' des Satzes genutzt werden, welche dann zufällig ausgewählt werden. 
Die Wertebereiche der Aufgaben müssen sich in einem realistischen Bereich bewegen, um nahezu an die Realtität zu kommen, sodass sich der Text umso mehr 'real' anfühlt.

==== Anforderungen
Aus diesen Gegebenheiten ergeben sich folgende Anforderungen an die Software

. Zufällige Generierung der Summen und Sachverhalte
. Guter Lesefluss in der Aufgabe durch unterschiedliche Satzstrukturen
. Generieren der Aufgabe und der Lösung
. Realistische Wertebereiche
. Trennung der Generierung und Lösung

=== Technische Umsetzung
==== Allgemeine Architektur
Die Software bildet besteht aus einem Server, welcher die Aufgaben zentral verwaltet, generiert, löst und die Lösungen prüft, sowie einem Client, welcher sich Aufgaben generieren lässt, selbige löst und Lösungen prüfen lässt. 
Der Server stellt REST-Endpunkte für den Client bereit, welche je nach Funktionalität angesprochen werden. Der Client bietet den Studierenden ein Frontend zur Bedienung und Interaktion mit ALADIN. Ich habe hier eine klare Trennung vorgenommen, einerseits Python, mit seinen zahlreichen Funktionen in Richtung KI, unterzubringen und JavaScript damit die UI responsiv und dynamisch sein kann. Außerdem kann weiterhin kklar zwischen den Funktionalitäten abgegrenzt und seperat an ihnen gearbeitet werden. Das ganze nur als einzelne Webanwendung zu betreiben, war in den Funktionalitäten so eingegrenzt, dass ich mich dazu entschieden habe, hier diese Trennung vorzunehmen. 

==== Wahl der Frameworks
Der Server wurde in Python programmiert. Einerseits, weil es die Programmiersprache ist, in der ich am fortgeschrittensten bin, andererseits, weil sich in Python viele Frameworks zum Language Processing angesiedelt haben. Als zwei Haupt-Frameworks habe ich PythonFastAPI (fastapi, https://fastapi.tiangolo.com), für die Bereitstellung der REST-Endpunkte sowie HuggingFace (https://huggingface.co), für die Language Processing gewählt. 

===== REST-API
Meine Wahl für das Framework für die REST-API fiel, wie beschrieben, auf FastAPI. FastAPI bietet eine sehr schnelle Bearbeitung der Requests und hat einen merkbaren Geschwindigkeitsvorteil. Das Framework benötigt ledigliche eine Datei für den Start und einen "uvicorn" als ASGI-Webserver umd Requests entgegenzunehmen. Zuerst habe ich den Webserver mit Flask betreiben, da hier aber die Abarbeitung der Requests nicht schnell genug war, habe ich auf FastAPI gewechselt. Die Dekoratoren für Funktionen der Endpunkte ist aber sehr ähnlich / nahezu gleich. Wer also Flask kennt, wird mit FastAPI wenig Probleme haben.

===== Frontend
Das Frontend habe ich aufgrund des Studiums mit Vuejs programmiert. Ich konnte hier bereits einige Erfahrungen in diesem Semestern sammeln und da ich die Lernkurve nicht als zu hoch empfand, habe ich mich für dieses Framework entschieden. Zuerst nur in einzelnen Aspekten, da aber die Aufgabenlösung und Anzeige eine dynamische Webseite erfordert, habe ich das komplette Frontend (vorher Flask mit Templates) auf komplett Vuejs umgestellt. Vuejs spricht je nach Funktionalität die REST-Endpunkte an um, im JSON Format, mit dem Server zu interagieren. Um ein einheitliches Styling zu gewährlisten habe ich als Frontend Framework Bootstrap gewählt.

==== Angewendete Konzepte
Um in folgenden Absätzen Fragen zu klären, erleutere ich zunächst, welche Konzepte und Ideen grundlegende Funktionalitäten in der Software umsetzen. Da wir im Steuerrecht unterschiedliche Sachverhalte pro Aufgabe haben, braucht es eine Datenstruktur für die Sachverhalte. Um diese dann zufällig auszuzwählen bzw. aneinander zu hängen ist eine weitere Struktur von Nutzen, die diese Funktion übernimmt. 

===== Sachverhalt (Case)
Ein Sachverhalt, nachfolgend auch Case gennant, ist die Repräsentation der notwendigen Informationen zu einem steuerlichen Sachverhalt. Diese Informationen sind in meinen Augen

. Name des Sachverhalts
. Art des Sachverhalts (Gehalt, Vermietung, Werbungskosten, Beteiligung,...)
. Verb das zum Sachverhalt gehört
. Subjekt / handelnde Person im Sachverhalt
. Zugehörige Summe

Diese Informationen werden pro Sachverhalt einzeln gespeichert und durch einen Klasse (case.py) abgebildet. Für jeden Sachverhalt werden neuen Klassen instanziiert und mit entsrpechenden Werten gefüllt, welche auch nachträglich durch Getter und Setter manipuliert / ausgelesen werden können.
Die Klasse hält die notwendigen Infromationen wie folgt
[source,python]
____
    class Case:
        def __init__(self, name="", subject="", verb="", object="", number=0) -> None:
            self.name = name
            self.subject = subject
            self.verb = verb
            self.object = object
            self.number = number
____

===== Pool / Auswahl an Sachverhalten (Nodepool)
Um alle instanziierten Sachverhalte in einer Datenstruktur halten zu können, benötigt es eine, dem Case übergeordnete, Datenstruktur. Zuerst habe ich versucht, auch im Hinblick auf die Generierung, die Datenstruktur als Graph aufzubauen, bei der jeder Case ein eigener Unterknoten und die Blätter des Knotens die Informationen zum Case sind. Da dieser Ansatz im Aufbau nicht sehr intuitiv war, habe ich mich im Nachhinein für eine "Pool" entscheiden. Dieser Pool hält eine Liste an Sachverhalten und stellt Methoden bereit um gezielt oder zufällig Sachverhalte aus dem Pool auszuwählen, aber auch einzelne Sachverhalte hinzuzufügen oder zu löschen. Diese Funktionalität bildet die Klasse nodepool.py ab, welche ein direktes Zusammenspiel mit der case.py Klasse bildet. 
[source, python]
____
    class NodePool:
        def __init__(self, name: str) -> None:
            self.name = name
            self.nodes: List[Case] = []
____

===== Natürliche Sprache (Mask-Filling)
Die Cases stellen für jeden Sachverhalt Informationen bereit, die unbedingt in der Formulierung vorkommen müssen, woraus sich einzelne Satzbausteine ergeben, welche bei der Satzgenerierung angewendet werden müssen. Jedoch bleiben dann Trennwörter und andere "füllende" Satzbausteine übrig, welche nur mit viel Aufwand fest definiert werden können. Um diese "Lücken" zu schließen und unterschiedliche Satzstrukturen ausbilden zu können, habe ich mir das Konzept des Mask-Filling zu nutze gemacht. Mask-Filling lässt sich nutzen, in dem in den Sätzen Platzhalter, sogenannte "MASKS", eingebaut werden, welche nachträglich von einem Sprachmodel gefüllt werden. Das Sprachmodel teilt den Satz in Tokens auf und sucht aufgrund seiner vorhandenen Daten nach einem möglichst passenden Ersatz für die Maske im Satz, um die Maske danach zu ersetzen. Dabei ist zu beachten, dass das Sprachmodel *nicht* auf steuerliche Sachverhalte trainiert wurde und es daher auch öfter dazu kommen kann, dass die Trennwörter nicht in den Use-Case passen.

.Ungefüllte Masken im Satz
image:mask-beispiel.png[]

.Nachträglich gefüllte Masken
image:masken-gefüllt.png[]

===== Strategy Pattern
Da bei der Aufgabengenerierung, je nach Parameterkombination, ein unterschiedliches Verfahren genutzt werden muss, habe ich mir das Strategy Pattern zu nutze gemacht. Beim Strategy Pattern wird es einem Objekt bzw. einer Klasse möglich gemacht, ihr Verhalten zur Laufzeit zu ändern. Dafür benötigt man ein Interface, welches die Methoden definiert, die verwendet werden, einen Context, der sein Verhalten ändert, und die konkrete Implementierung der Methoden, welche verwendet werden sollen. Mit diesem Design kann die Aufgabengenerierung ohne tief verzweigte If-Schleifen den richtigen Algorithmus wählen, sowie eine einfache Änderung bzw. Erweiterung gewährleisten.
Das Pattern wird in der Datei `generator_strategy.py` umgesetzt. Die Klasse `GeneratorStrategie` stellt das Interface mit der *generate* Methode bereit und verwendet dabei die Python Bibliothek *Abstract Base Classes*, um eine abstrakte Methode zu definieren. Alle Klassen die diese Klasse erben, definieren die konkreten Methoden und die *Context* Klasse nutzt diese Methoden. Folgende Strategien werden aktuell verwendet:

.Strategy Patterns
|===
|Anzahl Sachverhalte | Anzahl unterschiedliche Sachverhalte | Muss enthalten sein | Strategie

| gesetzt
| gesetzt
| gesetzt
| _WithDifficultyAndNeededAndAmount_


| gesetzt
| gesetzt
| nicht gesetzt
| _WithDifficultyAndAmount_

|===

Da nur der Parameter *Muss enthalten sein* optional ist, sind aktuell nur diese Strategien notwendig. 

==== Backend / REST-API
===== Ordnerstruktur

Die REST-API befindet sich im 'backend' Ordner. Hier gibt es die Subordner und Dateien:

image:backend-folder.png[]

* `generate_tasks.py` -> Datei, welche Logik zur Generierung der Aufgaben enthält
* `generator_strategie.py` -> Dateien für das Strategy Pattern um dynamisch Algorithmen zur Generierung zu wählen
* `main.py` -> FastAPI-Datei, welche gestartet wird und Hauptfunktionen enthält
* `/json` -> Ablage JSON-Dateien zum Test
* `/library` -> Bibliotheken für andere Module
* `/library/nodepool/case.py` -> Klasse, welche einen Sachverhalt repräsentiert
* `/library/nodepool/nodepool.py` -> Klasse, welche einen Pool aus Sachverhalten repräsentiert, welche zufällig gewählt werden
* `/library/dependencies.py` -> Auflösen und Generieren aller Einnahmen / Ausgaben Fälle
* `/library/laws.py` -> Festgelegte, gesetzliche Grundlagen der Fälle
* `/library/numbers.py` -> Wertebereiche der Fälle und Rundungsregeln
* `/library/sentenceparts.py` -> Satzbausteine für die einzelnen Fälle
* `/library/solution.py` -> Klasse, welche eine Lösung für einen Fall darstellt
* `/library/task.py` -> Klasse, welche eine Aufgabe mit den einzelnen Fällen darstellt
* `/library/variations.py` -> Stellt Funktionen des Sprachmodells bereit und bildet die unterschiedlichen Formulierungen für einen Sachverhalt

===== Generierung der Aufgaben
Die Aufgaben werden auf Anfrage des Clients je nach Parametern generiert. Folgende Parameter werden im Moment unterstützt:

* Anzahl der Sachverhalte
* Anzahl der unterschiedlichen Sachverhalte
* Sachverhalte welche in der Aufgabe enthalten sein müssen

Diese Parameter können vom Nutzer modifiziert werden und beeinflussen die Aufgabengenerierung. Die Studierenden können diese Parameter über die UI verändern, welche sich dann im Request für die Aufgabengenerierung widerspiegeln. 
Der Aufgaben- / Task-Endpunkt nimmt diese drei Parameter entgegen und wählt mit der `determine_strategy` Methode die Strategie für die Kombination der Parameter für den Context. Darauf werden zuerst die gewünschten Cases aus dem Pool gepickt, danach wird geprüft ob dann bereits die geforderte Anzahl der Cases erreicht ist, wenn nicht werden die restlichen Cases zufällig aufgefüllt, wenn ja werden nur die Cases, die gewünscht sind zurückgegeben. Aus den Cases werden im Anschluss die Lösungen für den Server berechnet sowie die korrekten rechtlichen Grundlagen zugewiesen. Außerdem wird das zu versteuernde Einkommen berechnet und aus den Cases ein Task erstellt, welcher jeder Aufgabe über eine ID identifiziert und eine Liste der Cases, Lösungen und das zvE enthält. Als letztes wird ein JSON vorbereitet, welches die ID des Task sowie alle Cases enthält, bei welchen ein Satz aus jedem Case in der Liste im Task gebaut wird. Für die Generierung der Sätze, werden die unterschiedlichen Satzkonstruktionen in `variations.py` genutzt, welche die *[MASK]* Tokens an unterschiedlichen Stellen als String enthalten. Es wird eine zufällige Variations ausgewählt und anschließend werden alle Masken im Satz durch das Sprachmodel gefüllt, dann wird der Satz zurückgegeben. 
image:mask-variations.png[]
Für eine gesamte Übersicht der Tasks in der Sitzung des Nutzers, hält der Server eine Liste an Tasks, welche bei jeder neuen Generierung um den neuen Task erweitert wird.

Task-Klasse
[source, python]
____
    class Task:
        id_generated = itertools.count()

        def __init__(self, cases: list[Case] = [], zve: int = 0, solutions: dict[str, Solution] = {}) -> None:
            self.id = next(Task.id_generated)
            self.cases: list[Case] = cases
            self.solutions: dict[str, Solution] = solutions
            self.zve = zve
            self.solved = {sol_id: {'name': False, 'law': False, 'num': False} for sol_id in self.solutions.keys()}

        def to_dict(self):
            return {"id": self.id, "case": [case.to_dict() for case in self.cases], "solved": self.solved}

        def all_solved(self):
            correct = 0
            for is_correct in self.solved.values():
                if all(is_correct.values()):
                    correct +=1
            return True if correct == len(self.solutions) else False
____


==== Frontend
===== Ordnerstruktur
Das Frontend ist ein Vuejs Projekt und befindet sich im 'frontend' Ordner. Dabei finden sich die Vuejs typischen Unterordner:

image:frontend-folder.png[]

* `index.html` -> Basis Landing page mit nötigen Script importen und Vuejs App-Container
* `/node_modules` -> Module von Nodejs, die benötigt werden
* `/public` -> Ordner für statische Assetss
* `/src/App.vue` -> Vuejs Haupt App Komponenente
* `/src/main.js` -> Vuejs Javascript main Datei um App auf Container in index.html zu mounten
* `/src/assets` -> Weiterer Ordner für statische Assets
* `/src/components/MainAppComponent.vue` -> Vereint alle Komponenten / Spiegel Layout unter Komponenten wieder
* `/src/components/AllTasksComponent.vue` -> Anzeigen aller Tasks auf Server
* `/src/components/CostumizeTaskComponent.vue` -> Buttons zum einstellen der Aufgabenparameter
* `/src/components/ErrorComponent.vue` -> Anzeigen von Errors in der Anwendung
* `/src/components/GivenSolutionComponent.vue` -> Anzeige der Lösungstabelle der Aufgabe
* `/src/components/store.js` -> Datenstruktur um Daten zwischen Komponenten auszutauschen
* `/src/components/TaskSentenceComponent.vue` -> Stellt alle generierten Sätze der Aufgabe da
* `/src/components/UploadFooterComponent` -> Upload von Konfigurationen (nicht funktionsfähig)
* `/src/components/UserSolutionComponent.vue` -> Lösungsstruktur des Nutzers um Aufgaben zu bearbeiten

===== Einzelne Komponenten
Im Folgenden erkläre ich alle Komponenten die ich im Frontend verwendet habe, dabei setzte ich grundglegendes Wissen in Vuejs / Javascript voraus. Für das Styling wird das CSS-Framework Bootstrap verwendet.

====== MainAppComponent
Der MainAppComponent vereint alle Komponenten der Vuejs Anwendung in einem zentralen Bootstrap Layout. Hier gibt es einen zentralen Container, der mehrere Bootstrap Rows beinhaltet. Auf der erstene Row findet sich der `AllTasksComponent`, welcher sich je nach Anzahl der Tasks skaliert und wächst. Darunter befinden sich der `TaskSentenceComponent` mit dem `CostumizeTaskComponent` auf einer Ebene. Beide Komponenten werden dabei zentriert und beanspruchen gleich viel Platz in der Horizontalen. Darunter folgen, jeweils in separaten Reihen, der `UserSolutionComponent`, zur Lösung des Users, der `GivenSolutionComponent` als vorgegebende Lösung, sowie der `ErrorComponent`, für mögliche Fehler in der Anwendung. Die Komponente hat sonst keine Funktionalität.

image:ui-konzept.png[]

====== AllTasksComponent
Im AllTasksComponent werden alle aktuellen Tasks dargestellt, welche vom Server generiert wurden. Hierbei wird für jeden Task ein button generiert der mit der ID des Tasks versehen wird. Je nachdem ob der Task gelöst wurde, wird entweder ein roter Button (nicht gelöst) oder ein grüner Button (gelöst) generiert. Die Komponente fragt je nach Änderung der im Store gespeicherten Task-ID den `/generated-tasks` Endpunkt ab und erhält ein JSON der aktuell generierten Tasks vom Server. 

[source, javascript]
____
    getGeneratedTasks() {
        axios.get("http://localhost:8000/generated-tasks")
            .then((res) => {
                this.generatedTasks = res.data
            }).catch((error) => {
                store.error = error.data
            });
    }
____

===== Kommunikation von Server und Client / Endpunkte
Server und Client kommunizieren über REST-Calls. Der Client sendet je nach gewünschter Funktionalität / Endpunkt eine Anfrage an den Server, welche dann entsprechend beantwortet wird. 

=== Ergebnisse

=== Ausblick