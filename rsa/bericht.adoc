:imagesdir: img

== RSA Verschlüsselung

=== Aufgabenbeschreibung
[#tasks]
==== Aufgabenstellung
Mithilfe dieses Aufgabentyps sollen Studierenden das RSA Verschlüsselungsverfahren verstehen und anwenden lernen. Die Studierenden müssen Schritt für Schritt durch die Aufgaben geführt werden. Zusätzlich sollen geeignete Lösungshilfen vorhanden sein, mit denen die Studierenden in der Lage sind Schritt für Schritt die Lösungen der Aufgaben erarbeiten. Durch unterschiedliche Schwierigkeitsgrade, bei denen die Studierenden stärker an die Hand genommen werden oder mehr Freiheit gegeben wird, können die Studieren ihre Fähigkeiten auf jeden jeweiligen Lernstand anpassen.

[#task_types]
==== Aufgabentypen
. Generierung des öffentlichen und des privaten Schlüssels
. Verschlüsselung von Zahlen und Text
. Entschlüsselung von Zahlen und Text
. Wählen einer teilerfremden Zahl bei gegebenen Werten

[#exercise]
===== Beispiel
.Beispielaufgabe RSA
image::example_exercise.png[pdfwidth=450px, width=450px]

[#requirements]
==== Anforderungen
* Zufällige Generierung der vorgegebenen Zahlen
* Schrittweise Anleitung
* Unterschiedliche Schwierigkeitsgrade
* Verständliche Lösungshilfen
* Vollständige Lösung

=== Umsetzung

==== Projektverlauf tbd.
Wie kann das Programm gestalltet werden, damit es möglichst gut durch den Benutzer konfiguriert werden kann und dass sogut wie kein Hardcoding stattfinden muss?

. Konsolenprogramm

.Konsolenprogramm für die Konfiguration
image:ConsoleProgramm.png[]
. Webapplikation

Striktes TypeScript wodurch teilweise erheblich mehr Aufwand in eine saubere Lösung investiert werden musste

Mehrfaches Refactoring
Dauerhafte Validierung der Benutzereingaben -> diese können erst weiter, wenn die vorherige Aufgabe richtig gelöst wurde.
image:validation_separate.png[]
Barrierefreiheit, automatischer Fokus aber auch komplexere Konfiguration der Felder (Validierungsbiliothek selbst geschrieben)
image:validation_basic.png[]
Programmierung der Lösungshilfen

===== Schlussfolgerungen
. Generische Konstruktoren
. Verwendung eines Konfigurtors, welcher entscheidet, welche Klassen instanziiert werden
. Mappings um komplexe `if-else`-Konstrukte oder `switch-case` zu vermeiden

[#technologies]
==== Verwendete Technologien

. Vite (Development-Server und Build Tool)
. ReactJS (JavaScript-Programmbibliothek zur Erstellung von webbasierten Benutzeroberflächen)
. TypeScript (Superset von JavaScript mit Typsystem und besserer Objektorientierung)

[#architecture]
==== Architektur
Im Idealfall sollte die Webapplikation aus einem Server bestehen, auf welchem die Aufgaben generiert werden und welcher die Rechenlast für die Verschlüsselungsaufgaben trägt und einem Client. Der Client würde dann nur die Aufgaben darstellen und mit dem Server kommunizieren.
Aktuell ist es so, dass die gesamte Logik im Client ausgeführt wird (FatClient) eine Aufteilung in den klassischen Server-Client ist noch nicht erfolgt. Somit ist die Geschwindikeit der Applikation wesentlich von den Ressourcen des Clients abhängig.

===== Backend
[#structure_backend]
.Programmaufbau - Backend
image::diagram_25_02_23.svg[]

===== Frontend
[#sequence_frontend]
.Programmaublauf - Frontend
image::activity_diagram_frontend.svg[]

=== Probleme
* Geschwindikeit der Applikation ist von der Rechenleistung des Clients abhängig siehe
link:#architecture[Architektur]
* Ver-/Entschlüsselung lief mit dem Datentyp `number` nicht immer zuverlässig, da hier unter Umständen die Zahlen abgeschnitten wurden => Einführung `BigInt`
* Größe des BigInt in TypeScript
+
Die Verschlüsselung von Text war ursprünglich mittels Bytestream geplant. Dadurch entstehen allerdings sehr schnell sehr große Zahlen und Schlüssel, welche so in der gewählten Programmiersprache (TypeScript) nicht darstellbar waren und mit welchen nicht gerechnet werden konnte.
+
.Probleme mit der Größe des BigInt
|===
|image:problem_bytestream.png[]|image:bitint_exceeded.png[]

|===
+
Von nun an erfolgt die Verschlüsselung von Text Buchstabe-für-Buchstabe. Vorteil dieser Variante, ist es, dass es für die Studierenden leicht zu verstehen und einfacher in der Anwendung ist.
+
.Verarbeitung des Textes Schritt für Schritt
image::encode_decode_step_by_step.png[]
* Nicht darstellbare ASCII-Zeichen z.Bsp. Backslash, LineFeed
+
Einige Ascii-Zeichen lassen sich nicht wirklich darstellen, diese haben in meinem Programm eine eigene Darstellung bekommmen = [*]. Für die Verwertung dieser Strukuren mussten komplexere Funktionen geschrieben werden, welche die Zeichenketten aus dem gesamt String extrahieren und umwandeln konnten.
+
image::asciitable.png[]
* Wertebereich für das Ver-/Entschlüsseln von Text
+
Es sollen ausschließlich Ascii-Zeichen und keine Unicode Zeichen angezeigt werden. Unicode-Zeichen sind vorallem für deutschsprachige Studierende schwer zu deuten (asiatische Schriftzeichen).
Deshalb werden immer die selben Schlüssel für das Ver-/Entschlüsseln von Text verwendet. 
+
====
const rsaString = new Rsa({p: 3, q: 43, e: 5});
====

=== Ergebnisse tbd.
Das Repository ist link:https://github.com/a-schulz/ALADIN_Cryptography[hier] zu finden.
Außerdem habe ich eine Auführliche Softwaredokumentation generiert. Diese kann link: [hier] aufgerufen werden.
*Was habe ich dabei gelernt?tbd*

=== Ausblick
. Erweiterung um Textkomprimierung z.Bsp. Huffman-Code
+
Zusammen mit der Textkomprimierung und dem RSA Verschlüsselungsverfahren könnte sich eine Komplexaufgabe gestalten lassen.
. Interaktive Lösungshilfen
+
Studierende könnten direkt in den Lösungshilfen z.Bsp. Tabellen ausfüllen und diese auch als Lösung einreichen.
. BackEnd mit REST-Schnittstellen
+
Klare Trennung und bessere Ressourcennutzung.
. Programm um einen Prüfungsmodus erweitern
+
Denkbar ist eine abschließende Auswertung und Bewertung, wie gut die Aufgaben absolviert wurden und wie viele Fehler gemacht wurden.
. Zwischenschritte der Studierenden mitspeichern
+
Dadurch wird es möglich, die gleiche Aufgabe nochmal mit Kommilitonen und Lehrernden durchzugehen, falls Verständnisfragen aufkommen.
